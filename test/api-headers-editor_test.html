<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>api-headers-editor test</title>
  <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../../arc-polyfills/arc-polyfills.html">
  <link rel="import" href="../api-headers-editor.html">
  <script src="amf-loader.js"></script>
</head>

<body>
  <test-fixture id="BasicTestFixture">
    <template>
      <api-headers-editor></api-headers-editor>
    </template>
  </test-fixture>
  <script>
  /* global AmfLoader */
  suite('api-headers-editor', () => {
    let amfModel;
    let amfShape;
    suiteSetup(() => {
      return AmfLoader.load()
      .then((data) => {
        amfModel = data;
        data = data[0][ApiElements.Amf.ns.raml.vocabularies.document + 'encodes'][0];
        data = data[ApiElements.Amf.ns.raml.vocabularies.http + 'endpoint'][0];
        data = data[ApiElements.Amf.ns.w3.hydra.core + 'supportedOperation'][0];
        data = data[ApiElements.Amf.ns.w3.hydra.core + 'expects'][0];
        data = data[ApiElements.Amf.ns.raml.vocabularies.http + 'header'];
        amfShape = data;
      });
    });

    let element;
    suite('Basics', () => {
      setup(() => {
        element = fixture('BasicTestFixture');
      });

      test('value is undefined', () => {
        assert.isUndefined(element.value);
      });

      test('viewModel is empty', () => {
        assert.typeOf(element.viewModel, 'array');
        assert.lengthOf(element.viewModel, 0);
      });

      test('sourceMode is false', () => {
        assert.isFalse(element.sourceMode);
      });

      test('_transformerTarget is set', () => {
        assert.isTrue(element._transformerTarget === element);
      });

      test('Detects content type', function() {
        element.value = 'text:test\ncontent-type:application/test';
        assert.equal(element.contentType, 'application/test',
          'contentType equals application/test');
      });

      test('Handles request-headers-changed event', function() {
        const init = {
          detail: {
            value: 'Authorization: test'
          },
          bubbles: true,
          cancelable: true
        };
        const event = new CustomEvent('request-headers-changed', init);
        document.dispatchEvent(event);
        assert.equal(element.value, 'Authorization: test');
      });

      test('Don\'t handles canceled request-headers-changed event', function() {
        const init = {
          detail: {
            value: 'Authorization: test'
          },
          bubbles: true,
          cancelable: true
        };
        document.addEventListener('request-headers-changed', function(e) {
          e.preventDefault();
        });
        const event = new CustomEvent('request-headers-changed', init);
        document.dispatchEvent(event);
        assert.equal(element.value, undefined);
      });

      test('Handles request-header-changed event', function() {
        const init = {
          detail: {
            name: 'Authorization',
            value: 'test'
          },
          bubbles: true,
          cancelable: true
        };
        const event = new CustomEvent('request-header-changed', init);
        document.dispatchEvent(event);
        assert.equal(element.value, 'Authorization: test');
      });

      test('Don\'t handles canceled request-header-changed event', function() {
        const init = {
          detail: {
            name: 'Authorization',
            value: 'test'
          },
          bubbles: true,
          cancelable: true
        };
        document.addEventListener('request-header-changed', function(e) {
          e.preventDefault();
        });
        const event = new CustomEvent('request-header-changed', init);
        document.dispatchEvent(event);
        assert.equal(element.value, undefined);
      });
    });

    suite('Switching editors', () => {
      setup((done) => {
        element = fixture('BasicTestFixture');
        element.viewModel = [{
          binding: 'header',
          name: 'x-test',
          hasDescription: false,
          required: true,
          schema: {
            enabled: true,
            type: 'string',
            inputLabel: 'x-string',
            isEnum: false,
            isArray: false,
            isBool: false,
            inputType: 'text'
          },
          value: ''
        }];
        flush(() => done());
      });

      test('Form data is default editor', () => {
        const editor = element.shadowRoot.querySelector('api-headers-form');
        assert.ok(editor);
      });

      test('Code mirror is not in the DOM', () => {
        const editor = element.shadowRoot.querySelector('code-mirror');
        assert.notOk(editor);
      });

      test('Switching to source mode removes form editor', (done) => {
        element.sourceMode = true;
        flush(() => {
          const editor = element.shadowRoot.querySelector('api-headers-form');
          assert.notOk(editor);
          done();
        });
      });

      test('Switching to source mode add code mirror', (done) => {
        element.sourceMode = true;
        flush(() => {
          const editor = element.shadowRoot.querySelector('code-mirror');
          assert.ok(editor);
          done();
        });
      });

      test('currentPanel returns form editor for form mode', (done) => {
        flush(() => {
          const result = element.currentPanel;
          assert.equal(result.nodeName, 'API-HEADERS-FORM');
          done();
        });
      });

      test('currentPanel returns code mirror for source mode', (done) => {
        element.sourceMode = true;
        flush(() => {
          const result = element.currentPanel;
          assert.equal(result.nodeName, 'CODE-MIRROR');
          done();
        });
      });

      test('Updates model value after turning back to form mode', (done) => {
        element.sourceMode = true;
        // Value is set after 50 ms to ensure it's initialized
        setTimeout(() => {
          const editor = element.currentPanel;
          editor.value = 'x-test: test-value';
          element.sourceMode = false;
          assert.equal(element.viewModel[0].value, 'test-value');
          done();
        }, 55);
      });

      test('Updates editor when in source mode', (done) => {
        element.sourceMode = true;
        setTimeout(() => {
          const editor = element.currentPanel;
          editor.value = 'x-test: test-value';
          assert.equal(element.value, 'x-test: test-value');
          done();
        }, 55);
      });

      test('Adds custom header from source mode', (done) => {
        element.sourceMode = true;
        setTimeout(() => {
          const editor = element.currentPanel;
          editor.value = 'x-test: test-value\nx-custom: value';
          element.sourceMode = false;
          assert.lengthOf(element.viewModel, 2, 'Model has two items');
          assert.isTrue(element.viewModel[1].schema.isCustom, 'Second item is custom item');
          assert.equal(element.viewModel[1].name, 'x-custom', 'Name is set');
          assert.equal(element.viewModel[1].value, 'value', 'Value is set');
          done();
        }, 55);
      });
    });

    // test('instantiating the element with default properties works', () => {
    //   const element = fixture('BasicTestFixture');
    //   assert.equal(element.prop1, 'api-headers-editor');
    //   const elementShadowRoot = element.shadowRoot;
    //   const elementHeader = elementShadowRoot.querySelector('h2');
    //   assert.equal(elementHeader.innerHTML, 'Hello api-headers-editor!');
    // });

    suite('AMF data model', () => {
      let element;
      setup((done) => {
        element = fixture('BasicTestFixture');
        element.addEventListener('value-changed', function f(e) {
          if (!e.detail.value) {
            return;
          }
          element.removeEventListener('value-changed', f);
          flush(() => done());
        });
        element.amfModel = amfModel;
        element.amfHeaders = amfShape;
      });

      test('Generates view model from AMF shape', () => {
        assert.typeOf(element.viewModel, 'array');
        assert.lengthOf(element.viewModel, 19);
      });

      test('Model respects default values', () => {
        const xRequired = element.viewModel[4];
        assert.equal(xRequired.value, 'required header');
      });

      test('Generates value from the model', (done) => {
        setTimeout(() => {
          const value = element.value;
          assert.notEqual(value.indexOf('ETag'), -1);
          assert.notEqual(value.indexOf('Cache-Control'), -1);
          assert.notEqual(value.indexOf('x-string'), -1);
          assert.notEqual(value.indexOf('x-optional'), -1);
          done();
        }, 250);
      });

      test('Clears AMF model when value is cleared', (done) => {
        element.value = undefined;
        flush(() => {
          assert.typeOf(element.viewModel, 'array');
          assert.lengthOf(element.viewModel, 0);
          done();
        });
      });
    });
  });

  suite('content-type-changed support', () => {
    let element;
    setup(() => {
      element = fixture('BasicTestFixture');
    });

    test('Fires content type change event', function(done) {
      const ct = 'application/test';
      element.addEventListener('content-type-changed', function clb(e) {
        element.removeEventListener('content-type-changed', clb);
        assert.equal(e.detail.value, ct);
        done();
      });
      element.value = 'text:test\ncontent-type:' + ct;
    });

    function fire(type) {
      window.dispatchEvent(new CustomEvent('content-type-changed', {
        detail: {
          value: type
        },
        cancelable: false,
        bubbles: true,
        composed: true
      }));
    }

    test('Updates content type value from the event', () => {
      const ct = 'test';
      fire(ct);
      assert.equal(element.contentType, ct);
    });

    test('Adds header to custom list', () => {
      const ct = 'test';
      fire(ct);
      assert.equal(element.viewModel[0].value, ct);
    });

    test('Does not refire the event', () => {
      const spy = sinon.spy();
      document.body.addEventListener('content-type-changed', spy);
      fire('test');
      assert.isFalse(spy.called);
    });
  });
  </script>
</body>

</html>
