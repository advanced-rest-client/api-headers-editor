<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>api-headers-editor test</title>

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../../mocha/mocha.js"></script>
  <script src="../../../chai/chai.js"></script>
  <script src="../../../wct-mocha/wct-mocha.js"></script>
  <script src="../../../sinon/pkg/sinon.js"></script>

  <script src="../../../codemirror/lib/codemirror.js"></script>
  <script src="../../../codemirror/addon/mode/loadmode.js"></script>
  <script src="../../../codemirror/mode/meta.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/headers-addon.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/show-hint.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/hint-http-headers.js"></script>

  <script src="./amf-loader.js"></script>
</head>

<body>
  <test-fixture id="BasicTestFixture">
    <template>
      <api-headers-editor></api-headers-editor>
    </template>
  </test-fixture>

  <test-fixture id="ReadOnly">
    <template>
      <api-headers-editor readonly></api-headers-editor>
    </template>
  </test-fixture>

  <test-fixture id="SourceMode">
    <template>
      <api-headers-editor source-mode></api-headers-editor>
    </template>
  </test-fixture>

  <script type="module">
  import '../api-headers-editor.js';
  suite('api-headers-editor', () => {
    let element;
    suite('Basics', () => {
      setup(() => {
        element = fixture('BasicTestFixture');
      });

      test('value is undefined', () => {
        assert.isUndefined(element.value);
      });

      test('sourceMode is false', () => {
        assert.isFalse(element.sourceMode);
      });

      test('_transformerTarget is set', () => {
        assert.isTrue(element._transformerTarget === element);
      });

      test('Detects content type', function() {
        element.value = 'text:test\ncontent-type:application/test';
        assert.equal(element.contentType, 'application/test',
          'contentType equals application/test');
      });

      test('Handles request-headers-changed event', function() {
        const init = {
          detail: {
            value: 'Authorization: test'
          },
          bubbles: true,
          cancelable: true
        };
        const event = new CustomEvent('request-headers-changed', init);
        document.dispatchEvent(event);
        assert.equal(element.value, 'Authorization: test');
      });

      test('Don\'t handles canceled request-headers-changed event', function() {
        const init = {
          detail: {
            value: 'Authorization: test'
          },
          bubbles: true,
          cancelable: true
        };
        document.addEventListener('request-headers-changed', function(e) {
          e.preventDefault();
        });
        const event = new CustomEvent('request-headers-changed', init);
        document.dispatchEvent(event);
        assert.equal(element.value, undefined);
      });

      test('Handles request-header-changed event', function() {
        const init = {
          detail: {
            name: 'Authorization',
            value: 'test'
          },
          bubbles: true,
          cancelable: true
        };
        const event = new CustomEvent('request-header-changed', init);
        document.dispatchEvent(event);
        assert.equal(element.value, 'Authorization: test');
      });

      test('Don\'t handles canceled request-header-changed event', function() {
        const init = {
          detail: {
            name: 'Authorization',
            value: 'test'
          },
          bubbles: true,
          cancelable: true
        };
        document.addEventListener('request-header-changed', function(e) {
          e.preventDefault();
        });
        const event = new CustomEvent('request-header-changed', init);
        document.dispatchEvent(event);
        assert.equal(element.value, undefined);
      });
    });

    suite('Switching editors', () => {
      setup((done) => {
        element = fixture('BasicTestFixture');
        element.viewModel = [{
          binding: 'header',
          name: 'x-test',
          hasDescription: false,
          required: true,
          schema: {
            enabled: true,
            type: 'string',
            inputLabel: 'x-string',
            isEnum: false,
            isArray: false,
            isBool: false,
            inputType: 'text'
          },
          value: ''
        }];
        flush(() => done());
      });

      test('Form data is default editor', () => {
        const editor = element.shadowRoot.querySelector('api-headers-form');
        assert.ok(editor);
      });

      test('Code mirror is not in the DOM', () => {
        const editor = element.shadowRoot.querySelector('code-mirror');
        assert.notOk(editor);
      });

      test('Switching to source mode removes form editor', (done) => {
        element.sourceMode = true;
        flush(() => {
          const editor = element.shadowRoot.querySelector('api-headers-form');
          assert.notOk(editor);
          done();
        });
      });

      test('Switching to source mode add code mirror', (done) => {
        element.sourceMode = true;
        flush(() => {
          const editor = element.shadowRoot.querySelector('code-mirror');
          assert.ok(editor);
          done();
        });
      });

      test('currentPanel returns form editor for form mode', (done) => {
        flush(() => {
          const result = element.currentPanel;
          assert.equal(result.nodeName, 'API-HEADERS-FORM');
          done();
        });
      });

      test('currentPanel returns code mirror for source mode', (done) => {
        element.sourceMode = true;
        flush(() => {
          const result = element.currentPanel;
          assert.equal(result.nodeName, 'CODE-MIRROR');
          done();
        });
      });

      test('Updates model value after turning back to form mode', (done) => {
        element.sourceMode = true;
        // Value is set after 50 ms to ensure it's initialized
        setTimeout(() => {
          const editor = element.currentPanel;
          editor.value = 'x-test: test-value';
          element.sourceMode = false;
          assert.equal(element.viewModel[0].value, 'test-value');
          done();
        }, 55);
      });

      test('Updates editor when in source mode', (done) => {
        element.sourceMode = true;
        setTimeout(() => {
          const editor = element.currentPanel;
          editor.value = 'x-test: test-value';
          assert.equal(element.value, 'x-test: test-value');
          done();
        }, 55);
      });

      test('Adds custom header from source mode', (done) => {
        element.sourceMode = true;
        setTimeout(() => {
          const editor = element.currentPanel;
          editor.value = 'x-test: test-value\nx-custom: value';
          element.sourceMode = false;
          assert.lengthOf(element.viewModel, 2, 'Model has two items');
          assert.isTrue(element.viewModel[1].schema.isCustom, 'Second item is custom item');
          assert.equal(element.viewModel[1].name, 'x-custom', 'Name is set');
          assert.equal(element.viewModel[1].value, 'value', 'Value is set');
          done();
        }, 55);
      });
    });

    // test('instantiating the element with default properties works', () => {
    //   const element = fixture('BasicTestFixture');
    //   assert.equal(element.prop1, 'api-headers-editor');
    //   const elementShadowRoot = element.shadowRoot;
    //   const elementHeader = elementShadowRoot.querySelector('h2');
    //   assert.equal(elementHeader.innerHTML, 'Hello api-headers-editor!');
    // });
  });

  suite('content-type-changed support', () => {
    let element;
    setup(() => {
      element = fixture('BasicTestFixture');
    });

    test('Fires content type change event', function(done) {
      const ct = 'application/test';
      element.addEventListener('content-type-changed', function clb(e) {
        element.removeEventListener('content-type-changed', clb);
        assert.equal(e.detail.value, ct);
        done();
      });
      element.value = 'text:test\ncontent-type:' + ct;
    });

    function fire(type) {
      window.dispatchEvent(new CustomEvent('content-type-changed', {
        detail: {
          value: type
        },
        cancelable: false,
        bubbles: true,
        composed: true
      }));
    }

    test('Updates content type value from the event', () => {
      const ct = 'test';
      fire(ct);
      assert.equal(element.contentType, ct);
    });

    test('Adds header to custom list', () => {
      const ct = 'test';
      fire(ct);
      assert.equal(element.viewModel[0].value, ct);
    });

    test('Does not refire the event', () => {
      const spy = sinon.spy();
      document.body.addEventListener('content-type-changed', spy);
      fire('test');
      assert.isFalse(spy.called);
    });

    test('Updates value in source mode', (done) => {
      element.sourceMode = true;
      flush(() => {
        const ct = 'test';
        fire(ct);
        assert.equal(element.currentPanel.value, 'Content-Type: test');
        done();
      });
    });

    test('Updates the value on the editor', () => {
      const ct = 'test';
      fire(ct);
      assert.equal(element.value, 'Content-Type: test');
    });
  });

  suite('_attachSourceEditor()', () => {
    test('Adds panel to the DOM', (done) => {
      const element = fixture('BasicTestFixture');
      flush(() => {
        element._attachSourceEditor();
        const panel = element.shadowRoot.querySelector('code-mirror');
        assert.ok(panel);
        done();
      });
    });

    test('Sets panel mode', (done) => {
      const element = fixture('BasicTestFixture');
      flush(() => {
        element._attachSourceEditor();
        const panel = element.shadowRoot.querySelector('code-mirror');
        assert.equal(panel.mode, 'http-headers');
        done();
      });
    });

    test('Sets data-headers-panel attribute', (done) => {
      const element = fixture('BasicTestFixture');
      flush(() => {
        element._attachSourceEditor();
        const panel = element.shadowRoot.querySelector('code-mirror');
        assert.isTrue(panel.hasAttribute('data-headers-panel'));
        done();
      });
    });

    test('Sets editor read only', (done) => {
      const element = fixture('ReadOnly');
      flush(() => {
        element._attachSourceEditor();
        const panel = element.shadowRoot.querySelector('code-mirror');
        assert.isTrue(panel.readOnly);
        done();
      });
    });
  });

  suite('_readonlyChanged()', () => {
    let element;
    setup((done) => {
      element = fixture('BasicTestFixture');
      flush(() => done());
    });

    test('Does nothing in form mode', () => {
      element.sourceMode = false;
      element._readonlyChanged(true);
      const panel = element.currentPanel;
      assert.isUndefined(panel.readOnly);
    });

    test('Sets panel readOnly model when source mode', () => {
      element.sourceMode = true;
      element._readonlyChanged(true);
      const panel = element.currentPanel;
      assert.isTrue(panel.readOnly);
    });
  });

  suite('modelToValue()', () => {
    let element;
    setup(() => {
      element = fixture('BasicTestFixture');
    });

    test('Returns empty string when no model', () => {
      const result = element.modelToValue();
      assert.equal(result, '');
    });

    test('Uses "viewModel" when no argument', () => {
      element.viewModel = [{name: 'x-test', value: 'x-value', schema: {}}];
      const result = element.modelToValue();
      assert.equal(result, 'x-test: x-value');
    });

    test('Skips disabled items', () => {
      element.viewModel = [{name: 'x-test', value: 'x-value', schema: {enabled: false}}];
      element.allowDisableParams = true;
      const result = element.modelToValue();
      assert.equal(result, '');
    });

    test('Will not skip disabled item when disabling is not allowed', () => {
      element.viewModel = [{name: 'x-test', value: 'x-value', schema: {enabled: false}}];
      element.allowDisableParams = false;
      const result = element.modelToValue();
      assert.equal(result, 'x-test: x-value');
    });

    test('Allows enabled items', (done) => {
      element.viewModel = [{name: 'x-test', value: 'x-value', schema: {enabled: true}}];
      element.allowDisableParams = true;
      const result = element.modelToValue();
      assert.equal(result, 'x-test: x-value');
      flush(() => done());
    });
  });

  suite('_cmKeysHandler()', () => {
    let element;
    setup((done) => {
      element = fixture('SourceMode');
      flush(() => done());
    });

    test('Opens hints', () => {
      const panel = element.currentPanel;
      const editor = panel.editor;
      assert.ok(editor, 'Editor property is set');
      element._cmKeysHandler(editor);
      const container = panel.querySelector('code-mirror-hint-container');
      assert.ok(container, 'Hints container is in the DOM');
    });
  });

  suite('createCustom()', () => {
    let element;
    setup(() => {
      element = fixture('BasicTestFixture');
    });

    test('Returns an object', () => {
      const result = element.createCustom();
      assert.typeOf(result, 'object');
    });

    test('Creates schema property', () => {
      const result = element.createCustom({});
      assert.typeOf(result.schema, 'object');
    });

    test('Adds isCustom property', () => {
      const result = element.createCustom({});
      assert.isTrue(result.schema.isCustom);
    });

    test('Sets default type property', () => {
      const result = element.createCustom({});
      assert.equal(result.schema.type, 'string');
    });

    test('Respects existing type property', () => {
      const result = element.createCustom({
        schema: {
          type: 'integer'
        }
      });
      assert.equal(result.schema.type, 'integer');
    });

    test('Sets default enabled property', () => {
      const result = element.createCustom({});
      assert.isTrue(result.schema.enabled);
    });

    test('Re-enable item', () => {
      const result = element.createCustom({
        schema: {
          enabled: false
        }
      });
      assert.isTrue(result.schema.enabled);
    });

    test('Sets default inputLabel property', () => {
      const result = element.createCustom({});
      assert.equal(result.schema.inputLabel, 'Header value');
    });

    test('Respects existing type property', () => {
      const result = element.createCustom({
        schema: {
          inputLabel: 'test-lable'
        }
      });
      assert.equal(result.schema.inputLabel, 'test-lable');
    });
  });

  suite('_headerChangedHandler()', () => {
    let element;
    setup((done) => {
      element = fixture('BasicTestFixture');
      element.value = '';
      flush(() => done());
    });

    test('Ignores event when dispatched by self', () => {
      element._headerChangedHandler({
        composedPath: () => [element]
      });
      assert.equal(element.value, '');
    });

    test('Ignores cancelled event', () => {
      element._headerChangedHandler({
        composedPath: () => [],
        defaultPrevented: true
      });
      assert.equal(element.value, '');
    });

    test('Ignores event when no name', () => {
      element._headerChangedHandler({
        composedPath: () => [],
        defaultPrevented: false,
        detail: {
          name: '',
          value: ''
        }
      });
      assert.equal(element.value, '');
    });

    test('Updates value of the editor', () => {
      element._headerChangedHandler({
        composedPath: () => [],
        defaultPrevented: false,
        detail: {
          name: 'x-test',
          value: 'x-value'
        }
      });
      assert.equal(element.value, 'x-test: x-value');
    });

    test('Updates existing value', () => {
      element.value = 'x-test: x-value';
      element._headerChangedHandler({
        composedPath: () => [],
        defaultPrevented: false,
        detail: {
          name: 'x-test',
          value: 'x-other'
        }
      });
      assert.equal(element.value, 'x-test: x-other');
    });
  });

  suite('_headerDeletedHandler()', () => {
    let element;
    const defaultValue = 'x-header: x-value';
    setup((done) => {
      element = fixture('BasicTestFixture');
      element.value = defaultValue;
      flush(() => done());
    });

    test('Ignores cancelled event', () => {
      element._headerDeletedHandler({
        defaultPrevented: true
      });
      assert.equal(element.value, defaultValue);
    });

    test('Ignores event when no name', () => {
      element._headerDeletedHandler({
        defaultPrevented: false,
        detail: {
          name: ''
        }
      });
      assert.equal(element.value, defaultValue);
    });

    test('Removes the header', () => {
      element._headerDeletedHandler({
        defaultPrevented: false,
        detail: {
          name: 'x-header'
        }
      });
      assert.equal(element.value, '');
    });

    test('Keeps not removed headers', () => {
      element._headerDeletedHandler({
        defaultPrevented: false,
        detail: {
          name: 'z-header'
        }
      });
      assert.equal(element.value, defaultValue);
    });
  });

  suite('refresh()', () => {
    test('Does nothing when not is source mode', (done) => {
      const element = fixture('BasicTestFixture');
      flush(() => {
        element.refresh();
        // no error
        done();
      });
    });

    test('Updates code editor', (done) => {
      const element = fixture('SourceMode');
      flush(() => {
        const panel = element.currentPanel;
        const spy = sinon.spy(panel, 'refresh');
        element.refresh();
        assert.isTrue(spy.called);
        done();
      });
    });
  });
  </script>
</body>

</html>
