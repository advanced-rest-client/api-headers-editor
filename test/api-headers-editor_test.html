<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>api-headers-editor test</title>
  <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../api-headers-editor.html">
</head>

<body>
  <test-fixture id="BasicTestFixture">
    <template>
      <api-headers-editor></api-headers-editor>
    </template>
  </test-fixture>
  <script>
  /* global sinon */
  suite('api-headers-editor', () => {
    let model;
    suiteSetup((done) => {
      const r = new XMLHttpRequest();
      r.addEventListener('load', () => {
        let data = r.response;
        try {
          data = JSON.parse(data);
        } catch (e) {
          done(e);
          return;
        }
        data = data[0]['http://raml.org/vocabularies/document#encodes'][0];
        data = data['http://raml.org/vocabularies/http#endpoint'][0];
        data = data['http://www.w3.org/ns/hydra/core#supportedOperation'][0];
        data = data['http://www.w3.org/ns/hydra/core#expects'][0];
        data = data['http://raml.org/vocabularies/http#header'];
        model = data;
        done();
      });
      r.open('GET', '../demo/headers-model.json');
      r.send();
    });

    let element;
    suite('Basics', () => {
      setup(() => {
        element = fixture('BasicTestFixture');
      });

      test('value is undefined', () => {
        assert.isUndefined(element.value);
      });

      test('viewModel undefined', () => {
        assert.isUndefined(element.viewModel);
      });

      test('sourceMode is false', () => {
        assert.isFalse(element.sourceMode);
      });

      test('_transformerTarget is set', () => {
        assert.isTrue(element._transformerTarget === element);
      });

      test('Detects content type', function() {
        element.value = 'text:test\ncontent-type:application/test';
        assert.equal(element.contentType, 'application/test', 'contentType equals application/test');
      });

      test('Fires content type change event', function() {
        const spy = sinon.stub();
        element.addEventListener('content-type-changed', spy);
        element.value = 'text:test\ncontent-type:application/test';
        assert.isTrue(spy.calledOnce);
      });
      test('Handles request-headers-changed event', function() {
        var init = {
          detail: {
            value: 'Authorization: test'
          },
          bubbles: true,
          cancelable: true
        };
        var event = new CustomEvent('request-headers-changed', init);
        document.dispatchEvent(event);
        assert.equal(element.value, 'Authorization: test');
      });

      test('Don\'t handles canceled request-headers-changed event', function() {
        var init = {
          detail: {
            value: 'Authorization: test'
          },
          bubbles: true,
          cancelable: true
        };
        document.addEventListener('request-headers-changed', function(e) {
          e.preventDefault();
        });
        var event = new CustomEvent('request-headers-changed', init);
        document.dispatchEvent(event);
        assert.equal(element.value, undefined);
      });

      test('Handles request-header-changed event', function() {
        var init = {
          detail: {
            name: 'Authorization',
            value: 'test'
          },
          bubbles: true,
          cancelable: true
        };
        var event = new CustomEvent('request-header-changed', init);
        document.dispatchEvent(event);
        assert.equal(element.value, 'Authorization: test');
      });

      test('Don\'t handles canceled request-header-changed event', function() {
        var init = {
          detail: {
            name: 'Authorization',
            value: 'test'
          },
          bubbles: true,
          cancelable: true
        };
        document.addEventListener('request-header-changed', function(e) {
          e.preventDefault();
        });
        var event = new CustomEvent('request-header-changed', init);
        document.dispatchEvent(event);
        assert.equal(element.value, undefined);
      });
    });

    suite('Switching editors', () => {
      setup(() => {
        element = fixture('BasicTestFixture');
        element.viewModel = [{
          binding: 'header',
          name: 'x-test',
          hasDescription: false,
          required: true,
          schema: {
            enabled: true,
            type: 'string',
            inputLabel: 'x-string',
            isEnum: false,
            isArray: false,
            isBool: false,
            inputType: 'text'
          },
          value: ''
        }];
      });

      test('Form data is default editor', () => {
        const editor = element.shadowRoot.querySelector('api-headers-form');
        assert.ok(editor);
      });

      test('Code mirror is not in the DOM', () => {
        const editor = element.shadowRoot.querySelector('code-mirror');
        assert.notOk(editor);
      });

      test('Switching to source mode removes form editor', () => {
        element.sourceMode = true;
        const editor = element.shadowRoot.querySelector('api-headers-form');
        assert.notOk(editor);
      });

      test('Switching to source mode add code mirror', () => {
        element.sourceMode = true;
        const editor = element.shadowRoot.querySelector('code-mirror');
        assert.ok(editor);
      });

      test('Passes "narrow" attribute to form editor', () => {
        element.narrow = true;
        const editor = element.shadowRoot.querySelector('api-headers-form');
        assert.isTrue(editor.narrow, 'Narrow is set');
        element.narrow = false;
        assert.isFalse(editor.narrow, 'Narrow is removed');
      });

      test('Passes "disallowCustom" attribute to form editor', () => {
        element.disallowCustom = true;
        const editor = element.shadowRoot.querySelector('api-headers-form');
        assert.isTrue(editor.disallowCustom, 'disallowCustom is set');
        element.disallowCustom = false;
        assert.isFalse(editor.disallowCustom, 'disallowCustom is removed');
      });

      test('formEditor() returns editor when form is on', () => {
        const result = element.formEditor();
        assert.ok(result);
      });

      test('formEditor() returns null when form is off', () => {
        element.sourceMode = true;
        const result = element.formEditor();
        assert.equal(result, null);
      });

      test('codeMirror() returns null when form is on', () => {
        const result = element.codeMirror();
        assert.equal(result, null);
      });

      test('codeMirror() returns element when form is off', () => {
        element.sourceMode = true;
        const result = element.codeMirror();
        assert.ok(result);
      });

      test('Updates model value after turning back to form mode', () => {
        element.sourceMode = true;
        const editor = element.codeMirror();
        editor.value = 'x-test: test-value';
        element.sourceMode = false;
        assert.equal(element.viewModel[0].value, 'test-value');
      });

      test('Updates editor when in source mode', () => {
        element.sourceMode = true;
        const editor = element.codeMirror();
        editor.value = 'x-test: test-value';
        assert.equal(element.value, 'x-test: test-value');
      });

      test('Adds custom header from source mode', () => {
        element.sourceMode = true;
        const editor = element.codeMirror();
        editor.value = 'x-test: test-value\nx-custom: value';
        element.sourceMode = false;
        assert.lengthOf(element.viewModel, 2, 'Model has two items');
        assert.isTrue(element.viewModel[1].isCustom, 'Second item is custom item');
        assert.equal(element.viewModel[1].name, 'x-custom', 'Name is set');
        assert.equal(element.viewModel[1].value, 'value', 'Value is set');
      });

      test('Disables missing headers in source code', () => {
        element.sourceMode = true;
        const editor = element.codeMirror();
        editor.value = 'x-custom: value';
        element.sourceMode = false;
        assert.lengthOf(element.viewModel, 2, 'Model has two items');
        assert.isFalse(element.viewModel[0].schema.enabled, 'Item is not enabled');
      });
    });

    // test('instantiating the element with default properties works', () => {
    //   const element = fixture('BasicTestFixture');
    //   assert.equal(element.prop1, 'api-headers-editor');
    //   const elementShadowRoot = element.shadowRoot;
    //   const elementHeader = elementShadowRoot.querySelector('h2');
    //   assert.equal(elementHeader.innerHTML, 'Hello api-headers-editor!');
    // });

  });
  </script>
</body>

</html>
