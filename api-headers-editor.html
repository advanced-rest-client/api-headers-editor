<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../api-view-model-transformer/api-view-model-transformer.html">
<link rel="import" href="../api-headers-form/api-headers-form.html">
<link rel="import" href="../code-mirror/code-mirror.html">
<link rel="import" href="../code-mirror-hint/code-mirror-hint.html">
<link rel="import" href="../code-mirror-hint/headers-addon.html">
<link rel="import" href="../code-mirror-hint/hint-http-headers.html">
<link rel="import" href="../arc-icons/arc-icons.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../headers-parser-behavior/headers-parser-behavior.html">
<link rel="import" href="../events-target-behavior/events-target-behavior.html">
<link rel="import" href="../clipboard-copy/clipboard-copy.html">
<link rel="import" href="../api-form-mixin/api-form-styles.html">
<dom-module id="api-headers-editor">
  <template>
    <style include="api-form-styles">
    :host {
      display: block;
      position: relative;

      @apply --raml-request-headers-editor;
    }

    paper-icon-button[active] {
      background-color: var(--api-headers-editor-panel-button-active-background-color, var(--raml-body-editor-panel-button-active-background-color, #e0e0e0));
      border-radius: 50%;
      @apply --raml-body-editor-panel-button-active;
      @apply --api-headers-editor-panel-button-active;
    }
    </style>
    <api-view-model-transformer amf-model="[[amfHeaders]]" view-model="{{viewModel}}" id="transformer" events-target="[[_transformerTarget]]"></api-view-model-transformer>
    <div class="content">
      <div class="editor-actions">
        <paper-icon-button class="action-icon" icon="arc:content-copy" on-tap="_copyToClipboard" title="Copy headers value to clipboard"></paper-icon-button>
        <paper-icon-button class="action-icon" icon="arc:code" toggles active="{{sourceMode}}" title="Toggle source edit mode"></paper-icon-button>
        <slot name="content-actions"></slot>
      </div>
      <div id="editor"></div>
    </div>
    <clipboard-copy content="[[value]]"></clipboard-copy>
  </template>
  <script>
    /**
     * `api-headers-editor`
     * An element to render headers edior based on AMF data model.
     *
     * By default it renders headers form. The user has an option to switch to
     * source editing mode. `code-mirror` element is used in the later case.
     *
     * ## AMF data model
     *
     * This element renders pre-configured form of headers based on
     * [AMF's](https://github.com/mulesoft/amf) json/ld data model.
     * From the model select `http://raml.org/vocabularies/http#header`
     * node which contains list of headers defined for current object
     * (it can be method, trait, security scheme etc).
     * The model is resolved to internal data model by `api-view-model-transformer`
     * element.
     *
     * ### Example
     *
     * ```html
     * <api-headers-editor id="editor"></api-headers-editor>
     * <script>
     * let data = await getAmfModel();
     * data = data[0]['http://raml.org/vocabularies/document#encodes'][0];
     * data = data['http://raml.org/vocabularies/http#endpoint'][0];
     * data = data['http://www.w3.org/ns/hydra/core#supportedOperation'][0];
     * data = data['http://www.w3.org/ns/hydra/core#expects'][0];
     * data = data['http://raml.org/vocabularies/http#header'];
     * (first endpoint, first method, headers array)
     * editor.amfModel = data;
     * editor.addEventListener('value-changed', (e) => console.log(e.detail.value));
     * < /script>
     * ```
     *
     * @customElement
     * @memberof ApiElements
     * @demo demo/index.html
     * @appliesMixin ArcBehaviors.HeadersParserBehavior
     * @appliesMixin ArcBehaviors.EventsTargetBehavior
     */
    class ApiHeadersEditor extends ArcBehaviors.EventsTargetBehavior(ArcBehaviors.HeadersParserBehavior(Polymer.Element)) {
      static get is() { return 'api-headers-editor'; }
      static get properties() {
        return {
          amfHeaders: Array,
          /**
           * Headers value.
           */
          value: {
            type: String,
            notify: true,
            observer: '_valueChanged'
          },
          /**
           * Generated view model fore the headers from `amfModel`.
           * This is automatically set when `amfModel` is set.
           */
          viewModel: {
            type: Array,
            observer: '_viewModelChanged'
          },
          /**
           * Value of a Content-Type header.
           * When this value change then editor update the value for the content type. However,
           * to change a single header value, please, use `request-headers-changed` event with `name`
           * and `value` properties set on the detail object.
           *
           * @type {Stirng}
           */
          contentType: {
            type: String,
            notify: true,
            observer: '_onContentTypeChanged'
          },

          /**
           * If set it will renders the view in the narrow layout.
           */
          narrow: {
            type: Boolean,
            observer: '_narrowChanged'
          },
          // When set to true then the source edit mode is enabled
          sourceMode: {
            type: Boolean,
            observer: '_sourceModeChanged'
          },
          /**
           * If set, custom headers won't be available in form mode.
           */
          disallowCustom: {
            type: Boolean,
            observer: '_disallowCustomChanged'
          },
          // Events target for tranformer
          _transformerTarget: {
            type: Object,
            value: function() {
              return this;
            }
          },
          // Regexp to search for content type value
          _contentTypeRe: {
            type: Object,
            value: function() {
              return /^[\t\r]*content\-type[\t\r]*:[\t\r]*([^\n]*)$/gim;
            }
          }
        };
      }
      /**
       * @constructor
       */
      constructor() {
        super();
        this._formValueChanged = this._formValueChanged.bind(this);
        this._cmValueChanged = this._cmValueChanged.bind(this);
        this._cmKeysHandler = this._cmKeysHandler.bind(this);
        this._headersChangedHandler = this._headersChangedHandler.bind(this);
        this._headerChangedHandler = this._headerChangedHandler.bind(this);
      }
      /**
       * Sets up editor when ready to manipulate DOM.
       */
      ready() {
        super.ready();
        this._sourceModeChanged(this.sourceMode);
      }

      _attachListeners(node) {
        node.addEventListener('request-headers-changed', this._headersChangedHandler);
        node.addEventListener('request-header-changed', this._headerChangedHandler);
      }

      _detachListeners(node) {
        node.removeEventListener('request-headers-changed', this._headersChangedHandler);
        node.removeEventListener('request-header-changed', this._headerChangedHandler);
      }
      /**
       * Creates a form editor and places it in the local DOM.
       * This does nothing if the element hasn't been yet initialized
       */
      createForm() {
        if (!this.$) {
          return;
        }
        this.removeForm();
        this.removeCodeMirror();
        const e = document.createElement('api-headers-form');
        e.model = this.viewModel;
        e.narrow = this.narrow;
        e.disallowCustom = this.disallowCustom;
        e.addEventListener('value-changed', this._formValueChanged);
        this.$.editor.appendChild(e);
      }
      /**
       * Searches the DOM for the form editor.
       *
       * @return {ApiHeadersEditor|undefined} Editor or undefined if not set.
       */
      formEditor() {
        return this.$.editor.querySelector('api-headers-form');
      }
      /**
       * Removes references to the form editor.
       * It removes event listeners and removes the form editor from local DOM.
       */
      removeForm() {
        const e = this.formEditor();
        if (!e) {
          return;
        }
        e.removeEventListener('value-changed', this._formValueChanged);
        this.$.editor.removeChild(e);
      }
      /**
       * Updates model data on form element.
       *
       * @param {Array} model New model
       */
      _updateFormModel(model) {
        const e = this.formEditor();
        if (!e) {
          return;
        }
        e.model = model;
      }
      /**
       * Updates form editor `narrow` property.
       *
       * @param {Boolean} narrow New value
       */
      _updateFormNarrow(narrow) {
        const e = this.formEditor();
        if (!e) {
          return;
        }
        e.narrow = narrow;
      }
      /**
       * Creates a code mirror editor and places it in the local DOM.
       * This does nothing if the element hasn't been yet initialized
       */
      createCodeMirror() {
        if (!this.$) {
          return;
        }
        this.removeForm();
        this.removeCodeMirror();
        const e = document.createElement('code-mirror');
        e.mode = 'http-headers';
        e.addEventListener('value-changed', this._cmValueChanged);
        e.value = this.modelToValue();
        e.setOption('extraKeys', {
          'Ctrl-Space': this._cmKeysHandler
        });
        this.$.editor.appendChild(e);
      }
      /**
       * Searches the DOM for the CodeMirror editor.
       *
       * @return {CodeMirrorElement|undefined} Editor or undefined if not set.
       */
      codeMirror() {
        return this.$.editor.querySelector('code-mirror');
      }
      /**
       * Removes references to the CodeMirror editor.
       * It removes event listeners and removes the editor from local DOM.
       */
      removeCodeMirror() {
        const e = this.codeMirror();
        if (!e) {
          return;
        }
        e.removeEventListener('value-changed', this._cmValueChanged);
        e.setOption('extraKeys', {});
        this.$.editor.removeChild(e);
      }
      /**
       * Updates model data on the `code-mirror` element.
       *
       * @param {Array} model New model
       */
      _updateCmModel(model) {
        const e = this.codeMirror();
        if (!e) {
          return;
        }
        e.value = this.modelToValue(model);
      }
      /**
       * Updates Code Mirror editor `narrow` property.
       *
       * @param {Boolean} narrow New value
       */
      _updateCmNarrow(narrow) {
        const e = this.codeMirror();
        if (!e) {
          return;
        }
        e.narrow = narrow;
      }
      // Updates the value when form data editor's value change
      _formValueChanged(e) {
        const value = e.detail.value;
        if (value !== this.value) {
          this.set('value', value);
        }
      }
      // Updates the value when CodeMirror editor's value change
      _cmValueChanged(e) {
        const value = e.detail.value;
        if (value !== this.value) {
          this.set('value', value);
        }
      }
      /**
       * Handler for `viewModel` change.
       * Updates currently opened editor.
       *
       * @param {Array} model New model
       */
      _viewModelChanged(model) {
        if (this.sourceMode) {
          this._updateCmModel(model);
        } else {
          this._updateFormModel(model);
        }
      }
      /**
       * Handler for `narrow` change.
       * Updates currently opened editor.
       *
       * @param {Boolean} narrow New value
       */
      _narrowChanged(narrow) {
        if (this.sourceMode) {
          this._updateCmNarrow(narrow);
        } else {
          this._updateFormNarrow(narrow);
        }
      }
      /**
       * Updates `disallowCustom` on form editor.
       *
       * @param {Boolean} state New state of property
       */
      _disallowCustomChanged(state) {
        if (!this.sourceMode) {
          const editor = this.formEditor();
          editor.disallowCustom = state;
        }
      }
      /**
       * Creates a headers string from a model.
       *
       * @param {?Array} model Optional, model to process. If not set it uses
       * `this.viewModel`
       * @return {String} Generated headers
       */
      modelToValue(model) {
        if (!model) {
          model = this.viewModel;
        }
        if (!model || !model.length) {
          return '';
        }
        const data = [];
        model.forEach((item) => {
          if (!item || (item.schema && item.schema.enabled === false)) {
            return;
          }
          data.push({
            name: item.name,
            value: item.value
          });
        });
        return this.headersToString(data);
      }
      /**
       * Code mirror's ctrl+space key handler.
       * Opens headers fill support.
       *
       * @param {Object} cm Code mirror instance.
       */
      _cmKeysHandler(cm) {
        /* global CodeMirror */
        CodeMirror.showHint(cm, CodeMirror.hint['http-headers'], {
          container: this.codeMirror()
        });
      }
      /**
       * Handler for `sourceMode` change.
       *
       * Opens desired editr.
       *
       * @param {Boolean} isSource
       */
      _sourceModeChanged(isSource) {
        if (isSource) {
          this.createCodeMirror();
        } else {
          this._modelFromValue();
          this.createForm();
        }
      }
      /**
       * Called when switching from source view to form view.
       * Updates view model with values defined in text editor.
       *
       * Only headers existing in `value` are going to be present in the model.
       * Otherwise headers will be disabled.
       *
       * It does nothing if `value` or `viewModel` is not defined.
       */
      _modelFromValue() {
        const value = this.value;
        if (value === undefined) {
          return;
        }
        const model = this.viewModel;
        if (!model) {
          return;
        }
        const parsedValue = this.filterHeaders(this.headersToJSON(value));
        const tmp = {};
        const appendCustom = [];
        // updates model value
        parsedValue.forEach((item) => {
          const i = this._findModelIndex(model, item.name);
          if (i === -1) {
            appendCustom.push(this.createCustom(item));
          } else {
            tmp[item.name] = true;
            if (model[i].value !== item.value) {
              if (model[i].schema.isArray) {
                this.set(['viewModel', i, 'value'], item.value.split(','));
              } else {
                this.set(['viewModel', i, 'value'], item.value);
              }
            }
            if (!model[i].schema.enabled) {
              this.set(['viewModel', i, 'schema', 'enabled'], true);
            }
          }
        });
        // Disables / removes not existing values.
        for (let i = model.length - 1; i >= 0; i--) {
          if (model[i].name in tmp) {
            continue;
          }
          if (model[i].isCustom) {
            this.splice('viewModel', i, 1);
          } else {
            this.set(['viewModel', i, 'schema', 'enabled'], false);
          }
        }
        appendCustom.forEach((item) => this.push('viewModel', item));
      }
      /**
       * Finds item position in model by name.
       *
       * @param {Array} model Model items
       * @param {String} name Header name to search for
       * @return {Number} Items position or `-1` if not found.
       */
      _findModelIndex(model, name) {
        return model.findIndex((item) => item.name === name);
      }
      /**
       * Creates a custom header model item.
       *
       * @param {Object} defaults Default data
       * @return {Object} View model item
       */
      createCustom(defaults) {
        const data = Object.assign({}, defaults);
        data.isCustom = true;
        if (!data.schema) {
          data.schema = {};
        }
        if (!data.schema.type) {
          data.schema.type = 'string';
        }
        if (!data.schema.enabled) {
          data.schema.enabled = true;
        }
        this.$.transformer.buildProperty(data);
        return data;
      }

      /**
       * Handler tor the `request-headers-changed` event.
       * Updates the editor value to the value of the event detail object.
       */
      _headersChangedHandler(e) {
        if (e.target === this) {
          return;
        }
        if (e.defaultPrevented) {
          return;
        }
        const value = e.detail.value;
        this._setValues(value);
      }
      /**
       * Handler for the `request-header-changed` event.
       * It updates value for a single header.
       */
      _headerChangedHandler(e) {
        if (e.defaultPrevented) {
          return;
        }
        const name = e.detail.name;
        if (!name) {
          return console.warn('request-header-changed fired without the name.');
        }
        const value = e.detail.value;
        const arr = this.headersToJSON(this.value);
        let updated = false;
        for (let i = 0, len = arr.length; i < len; i++) {
          if (arr[i].name.toLowerCase() === name.toLowerCase()) {
            arr[i].value = value;
            updated = true;
            break;
          }
        }
        if (!updated) {
          arr.push({
            name: name,
            value: value
          });
        }
        const headers = this.headersToString(arr);
        this._setValues(headers);
      }
      /**
       * Detects and sets content type value from changed headers value.
       *
       * @param {String} value Headers new value.
       */
      _detectContentType(value) {
        if (!value) {
          value = '';
        }
        this._contentTypeRe.lastIndex = 0;
        const matches = this._contentTypeRe.exec(value);
        let ctValue;
        if (!matches) {
          ctValue = '';
        } else {
          ctValue = matches[1];
        }
        if (!ctValue) {
          if (this.contentType) {
            this.set('contentType', undefined);
          }
        } else {
          if (this.contentType !== ctValue) {
            this.set('contentType', ctValue);
          }
        }
      }
      /**
       * Called by CodeMirror editor.
       * When something change n the headers list, detect content type header.
       */
      _valueChanged(value) {
        this._detectContentType(value);
        if (this._cacncelChangeEvent) {
          return;
        }
        const ev = new CustomEvent('request-headers-changed', {
          detail: {
            value: value
          },
          cancelable: true,
          bubbles: true,
          composed: true
        });
        this.dispatchEvent(ev);
      }

      _onContentTypeChanged(currentCt) {
        if (!currentCt) {
          this._notifyContentType('');
          return;
        }
        const arr = this.headersToJSON(this.value);
        let updated = false;
        let notChanged = false; //True when values are equal, no change needed.
        for (let i = 0, len = arr.length; i < len; i++) {
          if (arr[i].name.toLowerCase() !== 'content-type') {
            continue;
          }
          updated = true;
          if (arr[i].value === currentCt) {
            notChanged = true;
          } else {
            arr[i].value = currentCt;
          }
          break;
        }
        if (notChanged) {
          return;
        }
        if (!updated) {
          arr.push({
            name: 'Content-Type',
            value: currentCt
          });
        }

        const headers = this.headersToString(arr);
        this._setValues(headers);
        this._notifyContentType(currentCt);
      }

      _notifyContentType(type) {
        const ev = new CustomEvent('content-type-changed', {
          detail: {
            value: type
          },
          cancelable: false,
          bubbles: true,
          composed: true
        });
        this.dispatchEvent(ev);
      }

      _setValues(value) {
        this._cacncelChangeEvent = true;
        this.set('value', value);
        this._cacncelChangeEvent = false;
        if (this.sourceMode) {
          let editor = this.codeMirror();
          if (editor) {
            editor.value = value;
          }
        } else {
          this._modelFromValue();
        }
      }

      /**
       * Coppies current response text value to clipboard.
       */
      _copyToClipboard() {
        const button = this.$.copyButton;
        const copy = this.shadowRoot.querySelector('clipboard-copy');
        if (copy.copy()) {
          button.icon = 'arc:done';
        } else {
          button.icon = 'arc:error';
        }
        setTimeout(() => {
          this._resetCopyButtonState(button);
        }, 1000);
      }

      _resetCopyButtonState(button) {
        button.icon = 'arc:content-copy';
      }
    }

    window.customElements.define(ApiHeadersEditor.is, ApiHeadersEditor);
  </script>
</dom-module>
